{
 "type": "wiki",
 "title": "데이크스트라 알고리즘",
 "summary": "최단경로 알고리즘",
 "parent": "algorithm/graph",
 "url": "/wiki/algorithm/dijkstra",
 "updated": "2024-09-16 13:07:42 +0900",
 "resource": "28BF8765-DD61-43FE-8D87-4527461765BA",
 "children": [],
 "body": "\n* TOC\n{:toc}\n\n## 우선 순위 큐(min-heap)를 활용한 데이크스트라 알고리즘\n\n```cpp\n#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n\n  int v, e, s;\n  cin >> v >> e >> s;\n  vector<pair<int, int>> adj[v + 1];\n\n  for (int i = 0; i < e; ++i) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    adj[a].push_back({c, b});\n  }\n\n  priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n  vector<int> dist(v + 1, INT_MAX);\n\n  pq.push({0, s});\n  dist[s] = 0;\n  while (!pq.empty()) {\n    pair<int, int> cur = pq.top(); pq.pop();\n\n    // dist에 저장된 비용이 현재 노드의 비용과 다르다면 패스한다.\n    // dist에 저장된 비용은 항상 가장 적다.\n    if (dist[cur.second] != cur.first) continue;\n\n    for (const auto &nxt : adj[cur.second]) {\n      int cost = dist[cur.second] + nxt.first;\n      if (dist[nxt.second] <= cost) continue;\n      dist[nxt.second] = cost;\n      pq.push({dist[nxt.second], nxt.second});\n    }\n\n  }\n\n  for (int i = 1; i < dist.size(); ++i) {\n    if (dist[i] == INT_MAX) cout << \"INF\\n\";\n    else cout << dist[i] << \"\\n\";\n  }\n\n  return 0;\n}\n```\n\n## 경로 복원\n\n경로 테이블을 추가해 갱신이 일어날 때,\n갱신된 노드의 경로 테이블에 현재 노드를 기록해준다.\n\n경로를 구할 때는 원하는 노드에서 시작해 역순으로 따라간다.\n\n```cpp\n  ...\n  vector<int> dist(v + 1, INT_MAX);\n  vector<int> pre(v + 1, 0); // 경로 테이블, 존재하지 않는 0번 노드를 가르킨다.\n\n  pq.push({0, s});\n  dist[s] = 0;\n  while (!pq.empty()) {\n    pair<int, int> cur = pq.top();\n    pq.pop();\n    if (dist[cur.second] != cur.first)\n      continue;\n    for (const auto &nxt : adj[cur.second]) {\n      int cost = dist[cur.second] + nxt.first;\n      if (dist[nxt.second] <= cost)\n        continue;\n      pre[nxt.second] = cur.second; // 경로 테이블을 갱신한다.\n      dist[nxt.second] = cost;\n      pq.push({dist[nxt.second], nxt.second});\n    }\n  }\n  ...\n```\n\n## Links\n- [[바킹독의 실전 알고리즘] 0x1D강 - 다익스트라 알고리즘](https://youtu.be/o9BnvwgPT-o?si=E-5JK7EUX4pYNM1o)\n\n"
}